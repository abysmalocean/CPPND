## 06

The Model class that exists in the current code doesn't contain all the data or methods that will be needed to perform an A* search, so we are going to extend that class with a RouteModel class. In this exercise, you will fill out the RouteModel class in route_model.h. In the next exercises, you will also fill out the RouteModel::Node class as well.

## To complete this exercise:
In route_model.h:

Add a private vector of Node objects named m_Nodes. This will store all of the nodes from the Open Street Map data.
Add a public "getter" method SNodes. This method should return a reference to the vector of Nodes stored as m_Nodes.

## 07

The Node Class
The Model::Node class that exists in the current code doesn't contain all the data that would be needed to perfom an A* search. In order to perform a search, it would be ideal for each node to contain at least the following information:

The g-value for the node.
The h-value for the node.
A boolean to indicate if the node has been visited.
A pointer to the node's parent.
In this exercise, you will fill out the RouteModel::Node class in route_model.h, which will extend the Model::Node class so that the data above, along with a few other useful variables, can be included with each node. Note that the RouteModel::Node class already has the following private variables:

An int index.
A pointer to a RouteModel object named parent_model. This variable is important, as it allows each node to access data stored in the parent model that the node belongs to.
To complete this exercise:
Add the following public variables to the RouteModel::Node class:
A Node pointer parent, which is initialized to a nullptr.
A float h_value, which is initialized to the maximum possible: std::numeric_limits<float>::max().
A float g_value, which is initialized to 0.0.
A bool visited, which is initialized to false.
A vector of Node pointers named neighbors.

## 09 
Create RouteModel Nodes
Now that you have a RouteModel class and you have completed the RouteModel::Node nested class, you can create RouteModel nodes.

When the RouteModel constructor is called, it calls the Model constructor with the open street map data. When this happens, a collection of Model:Node objects are created. However, in order to perform the A* search, you will need to use RouteModel::Node objects instead.

In this exercise, you will modify the RouteModel constructor. The constructor will use the vector of Model:Node objects to create new RouteModel::Node objects. These RouteModel::Node objects will then be stored in the m_Nodes vector of the RouteModel.

## To complete this exercise:
In the RouteModel constructor in route_model.cpp, write a for loop with a counter to loop over the vector of Model::Nodes given by this->Nodes().
For each Model node in the loop, use the RouteModel::Node constructor to create a new node, and push the new node to the back of m_Nodes.
To do this, you should use the RouteModel::Node constructor that accepts three arguments:
  Node(int idx, RouteModel * search_model, Model::Node node)
The first argument is given by the counter index. The second argument should be a pointer to the RouteModel instance that the Node belongs to. Since you are writing your code inside the RouteModel constructor, you can use the this keyword to get a pointer to the current RouteModel instance. In other words, you can pass this as the second argument. The last argument is given by the Model::Node in the for loop.



# Write the Distance Function

As you write A* search, it will be useful to be able to find the distance between two nodes. This will allow the search algorithm to find the closest node to the current node. In this exercise, you will write a utility function that finds the distance between two RouteModel::Node objects.

## To complete this exercise:
Add a distance declaration to the RouteModel::Node class in route_model.h. This method should take a Node object as the argument, and it should return a float. The distance method shouldn't change the object being passed, so you can make it a const method (add const after the function name).
Return the euclidean distance from the current node to the node passed in. Note that for points (x_1, y_1)(x 


# L4 Create Node To Road Hashmap


Settings
Enter fullscreen
Play
When you begin to write A* search, you will be searching between two nodes on the map. We would like the search path to follow the roads that the nodes are on, but a given node doesn't have any information about which road it belongs to. To rectify this problem, you will write a function that creates a hash table of Node index values to a vector of Road pointers that those nodes belong to.

Note that each Model::Road object has a .way attribute, which is the index of the way that the road belongs to in the Ways() vector. Each Model::Way object has a .nodes attribute, which is a vector of node indices. This means that for a given Road object road, you can find all the node indices related to the road with Ways()[road.way].nodes.

## To complete this exercise:
Add a private variable node_to_road in the RouteModel class in route_model.h. This variable should be an unordered_map with an int key type, and a vector of const Model::Road* as the value type.
Add a method declaration CreateNodeToRoadHashmap in the RouteModel class in route_model.h. This method will operate only on the node_to_road variable declared above, and only within the RouteModel class, so it can be private, it needs no arguments, and can have void return type.
Add a method definition in route_model.cpp. In the body of the method, you will need to do the following:
Write a loop that iterates through the vector given by calling Roads().
For each reference &road in the vector, check that the type is not a footway: road.type != Model::Road::Type::Footway. If the road is not a footway:
Loop over each node_idx in the way that the road belongs to: Ways()[road.way].nodes.
If the node index is not in the node_to_road hashmap yet, set the value for the node_idx key to be an empty vector of const Model::Road* objects.
Push a pointer to the current road in the loop to the back of the vector given by the node_idx key in node_to_road.
Call CreateNodeToRoadHashmap() in the RouteModel constructor in route_model.cpp.
Lastly, add a public getter function GetNodeToRoadMap() in the RouteModel class in route_model.h. This function should return a reference to the node_to_road variable, and it will be primarily used for testing.